%% %%%%% NOTE ON RESULTS FOLDERS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% To use this analysis script to extract the controller performance files
% should be arranged as follows.
% 
% /sim_dual_*modelname* is the master folder of results for *modelname*
% /sim_dual_*modelname*/results_mat/ is the folder containing .mat files
% created by design_dual_*modelname*_bio_imp
% /sim_dual_*modelname*/results/ is the folder containing the .txt files
% containing the simulations results created by design_dual_*modelname*_bio_imp
%
% NOTE THAT these folders are not generated by
% design_dual_*modelname*_bio_imp and need to be created manually.

%% %%%%% SET UP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear('all'); close('all'); addpath('libmodels'); hname = pwd;

% model name % index of mrna m1 % index of protein p1 % index of mrna m2 % index of protein p2
modelid{ 1} = 'uber_or'; m1idx( 1) =  9; p1idx( 1) = 11; m2idx( 1) = 13; p2idx( 1) = 15;
modelid{ 2} = 'frag_or'; m1idx( 2) = 14; p1idx( 2) = 16; m2idx( 2) = 18; p2idx( 2) = 20; 
modelid{ 3} = 'sqtr_or'; m1idx( 3) =  9; p1idx( 3) = 11; m2idx( 3) = 13; p2idx( 3) = 15;
modelid{ 4} = 'op_or';   m1idx( 4) =  9; p1idx( 4) = 11; m2idx( 4) = 13; p2idx( 4) = 15;
modelid{ 5} = 'var_frag_or'; m1idx(5) = 14; p1idx(5) = 16; m2idx(5) = 18; p2idx(5) = 20; 
modelid{ 6} = 'ortho_op_or'; m1idx(6) =  9; p1idx(6) = 11; m2idx(6) = 13; p2idx(6) = 15;

% range of the simulation to assess the behaviour within
delta_0 = 0.75;
delta_1 = 0.95;

%% %%%%% LOAD AND ANALYSE MODELS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
for m = 2 % 1:length(modelid)
    
    %% %%%%% LOAD SIMULATION SETTINGS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    copyfile(['sim_dual_',modelid{m},'/results_mat/simulationsettings.mat'], ...
        ['model_',modelid{m},'_simulation_settings.mat']);
    
    % load number of simulations
    load(['model_',modelid{m},'_simulation_settings.mat'],'N','tind');
    
    %% %%%%% ITERATE OVER SIMULATIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    v_m1idx = m1idx(m); v_m2idx = m2idx(m);
    v_p1idx = p1idx(m); v_p2idx = p2idx(m);
    m1_ind = zeros(N,1); p1_ind = zeros(N,1);
    m2_ind = zeros(N,1); p2_ind = zeros(N,1);
    m1_end = zeros(N,1); p1_end = zeros(N,1);
    m2_end = zeros(N,1); p2_end = zeros(N,1);
    m1maxval_1 = zeros(N,1); m1minval_1 = zeros(N,1);
    p1maxval_1 = zeros(N,1); p1minval_1 = zeros(N,1);
    m1maxval_2 = zeros(N,1); m1minval_2 = zeros(N,1);
    p1maxval_2 = zeros(N,1); p1minval_2 = zeros(N,1);
    
    % cd to folder
    cd(['sim_dual_',modelid{m},'/results']);
    
    % iterate
    parfor i = 1:N
        
        disp(['... ',num2str(m),' ... ',num2str(i)]);
        
        % load initial indution
        simresult = dlmread(['i_',num2str(i),'_dynamics_1.txt']);
        T = simresult(:,1);
        Y = simresult(:,2:end);
        
        if T(end) == 2*tind
            
            m1_ind(i) = Y(end, v_m1idx);
            p1_ind(i) = Y(end, v_p1idx);
            m2_ind(i) = Y(end, v_m2idx);
            p2_ind(i) = Y(end, v_p2idx);
            
            % get indecies
            idx_0 = sum(T < min(T) + delta_0*tind);
            idx_1 = sum(T < min(T) + delta_1*tind);
            
            m1maxval_1(i) = max(Y(idx_0:idx_1, v_m1idx));
            m1minval_1(i) = min(Y(idx_0:idx_1, v_m1idx));
            p1maxval_1(i) = max(Y(idx_0:idx_1, v_p1idx));
            p1minval_1(i) = min(Y(idx_0:idx_1, v_p1idx));
            
        else
            
            m1_ind(i) = NaN;
            p1_ind(i) = NaN;
            m2_ind(i) = NaN;
            p2_ind(i) = NaN;
            m1maxval_1(i) = NaN;
            m1minval_1(i) = NaN;
            p1maxval_1(i) = NaN;
            p1maxval_1(i) = NaN;
            
        end
        
        % load second induction
        simresult = dlmread(['i_',num2str(i),'_dynamics_2.txt']);
        T = simresult(:,1);
        Y = simresult(:,2:end);
        
        if T(end) == 3*tind
            
            m1_end(i) = Y(end, v_m1idx);
            p1_end(i) = Y(end, v_p1idx);
            m2_end(i) = Y(end, v_m2idx);
            p2_end(i) = Y(end, v_p2idx);
            
            % get indecies
            idx_0 = sum(T < min(T) + delta_0*tind);
            idx_1 = sum(T < min(T) + delta_1*tind);
            
            m1maxval_2(i) = max(Y(idx_0:idx_1, v_m1idx));
            m1minval_2(i) = min(Y(idx_0:idx_1, v_m1idx));
            p1maxval_2(i) = max(Y(idx_0:idx_1, v_p1idx));
            p1minval_2(i) = min(Y(idx_0:idx_1, v_p1idx));
            
        else
            
            m1_end(i) = NaN;
            p1_end(i) = NaN;
            m2_end(i) = NaN;
            p2_end(i) = NaN;
            m1minval_2(i) = NaN;
            m1maxval_2(i) = NaN;
            p1maxval_2(i) = NaN;
            p1minval_2(i) = NaN;
            
        end
        
    end
    
    % return to main folder
    cd(hname);
    
    save(['model_',modelid{m},'_coupling.mat'], ...
        'v_m1idx', 'v_m2idx', 'v_p1idx', 'v_p2idx', ...
        'm1_ind', 'p1_ind', 'm2_ind', 'p2_ind', ...
        'm1_end', 'p1_end', 'm2_end', 'p2_end');
    save(['model_',modelid{m},'_max_min.mat'], ...
        'm1maxval_1', 'm1minval_1', 'p1maxval_1', 'p1minval_1', ...
        'm1maxval_2', 'm1minval_2', 'p1maxval_2', 'p1minval_2');
    
end
